# Staged: src/app/api/reports/translate/route.ts

```
{"status":"success","output":"import { NextResponse } from \"next/server\";\nimport { spawn } from \"child_process\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport { cookies } from \"next/headers\";\nimport { jwtVerify } from \"jose\";\nimport { prisma } from \"@/lib/prisma\";\nimport { captureScanReports } from \"@/lib/scan-utils\";\n\nconst SECRET = new TextEncoder().encode(process.env.JWT_SECRET || \"default_secret_key_12345\");\nconst ENGINE_DIR = process.env.ENGINE_DIR || \"/home/ubuntu/dokodemodoor\";\n\n// Use global to survive Hot Module Replacement (HMR) in Dev mode\ndeclare global {\n  var reportTranslations: Set<string> | undefined;\n}\n\nif (!global.reportTranslations) {\n  global.reportTranslations = new Set();\n}\nconst ongoingTranslations = global.reportTranslations;\n\nexport async function GET() {\n  return NextResponse.json({ translatingPaths: Array.from(ongoingTranslations) });\n}\n\nexport async function POST(req: Request) {\n  let requestPath = \"\";\n  try {\n    const { filePath } = await req.json();\n    if (!filePath) {\n      return NextResponse.json({ error: \"Missing filePath\" }, { status: 400 });\n    }\n    requestPath = filePath;\n\n    // Auth Check\n    const cookieStore = await cookies();\n    const token = cookieStore.get(\"auth_token\")?.value;\n    if (!token) return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n\n    try {\n      await jwtVerify(token, SECRET);\n    } catch {\n      return NextResponse.json({ error: \"Invalid token\" }, { status: 401 });\n    }\n\n    const REPOS_BASE_DIR = process.env.REPOS_DIR || \"/home/ubuntu/dokodemodoor/repos\";\n\n    // Security check\n    const resolvedPath = path.isAbsolute(filePath) ? filePath : path.join(REPOS_BASE_DIR, filePath);\n\n    if (!resolvedPath.startsWith(REPOS_BASE_DIR) && !resolvedPath.includes(\"/deliverables/\")) {\n        return NextResponse.json({ error: \"Forbidden path\" }, { status: 403 });\n    }\n\n    if (!fs.existsSync(resolvedPath)) {\n      console.error(`[TRANSLATE] File not found at: ${resolvedPath}`);\n      return NextResponse.json({ error: `File not found at ${resolvedPath}` }, { status: 404 });\n    }\n\n    // Duplicate Prevention (using the persistent global set)\n    if (ongoingTranslations.has(requestPath)) {\n      return NextResponse.json({ error: \"Translation for this file is already in progress.\" }, { status: 400 });\n    }\n\n    ongoingTranslations.add(requestPath);\n\n    return new Promise<NextResponse>((resolve) => {\n      let isDone = false;\n      const MAX_OUTPUT_SIZE = 1024 * 1024; // 1MB Limit to prevent OOM\n      let output = \"\";\n\n      const cleanup = () => {\n          if (isDone) return;\n          isDone = true;\n          ongoingTranslations.delete(requestPath);\n      };\n\n      const proc = spawn(\"npm\", [\"run\", \"translate-report\", resolvedPath], {\n        cwd: ENGINE_DIR,\n        env: { ...process.env, FORCE_COLOR: \"3\" }\n      });\n\n      // 5-minute Timeout\n      const timeout = setTimeout(() => {\n        if (!isDone) {\n          console.error(`[TRANSLATE] Timeout reached: ${resolvedPath}`);\n          proc.kill(\"SIGKILL\"); // Force kill on timeout\n          cleanup();\n          resolve(NextResponse.json({ error: \"Translation timed out (5 minutes limit reached)\", output }, { status: 504 }));\n        }\n      }, 5 * 60 * 1000);\n\n      proc.stdout.on(\"data\", (data) => {\n        if (output.length < MAX_OUTPUT_SIZE) {\n          output += data.toString();\n        } else if (!output.endsWith(\"\\n... (truncated)\")) {\n          output += \"\\n... (truncated)\";\n        }\n      });\n\n      proc.stderr.on(\"data\", (data) => {\n        if (output.length < MAX_OUTPUT_SIZE) {\n          output += data.toString();\n        }\n      });\n\n      proc.on(\"close\", async (code) => {\n        clearTimeout(timeout);\n        if (!isDone) {\n          cleanup();\n          if (code === 0) {\n            // Success: Trigger DB Sync if the project is registered\n            try {\n              // Extract project directory from resolvedPath\n              // (Path structure: .../repos/[project_name]/deliverables/[file])\n              const pathParts = resolvedPath.split(path.sep);\n              const reposIdx = pathParts.lastIndexOf(\"repos\");\n              if (reposIdx !== -1 && pathParts.length > reposIdx + 1) {\n                const projectPath = pathParts.slice(0, reposIdx + 2).join(path.sep);\n\n                // Find the latest scan for this project\n                const scan = await prisma.scan.findFirst({\n                  where: { sourcePath: projectPath },\n                  orderBy: { startTime: 'desc' }\n                });\n\n                if (scan) {\n                  console.log(`[TRANSLATE] Syncing reports to DB for scan: ${scan.id}`);\n                  await captureScanReports(scan.id, projectPath);\n                }\n              }\n            } catch (err) {\n              console.error(\"[TRANSLATE] DB Sync Error:\", err);\n            }\n\n            resolve(NextResponse.json({ success: true, message: \"Translation completed and synced to DB\", output }));\n          } else {\n            resolve(NextResponse.json({ error: `Translation failed with exit code ${code}`, output }, { status: 500 }));\n          }\n        }\n      });\n\n      proc.on(\"error\", (err) => {\n        clearTimeout(timeout);\n        if (!isDone) {\n          cleanup();\n          console.error(`[TRANSLATE] Spawn error: ${err.message}`);\n          resolve(NextResponse.json({ error: `Process error: ${err.message}`, output }, { status: 500 }));\n        }\n      });\n    });\n\n  } catch (err: unknown) {\n    if (requestPath) ongoingTranslations.delete(requestPath);\n    console.error(\"Report translation error:\", err);\n    return NextResponse.json({ error: \"Internal Server Error\" }, { status: 500 });\n  }\n}","exitCode":0}
```