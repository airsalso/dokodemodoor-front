# Staged: src/app/api/scan/start/route.ts

```
{"status":"success","output":"import { NextResponse } from \"next/server\";\nimport { spawn, type ChildProcess } from \"child_process\";\nimport { prisma } from \"@/lib/prisma\";\nimport { withAuth } from \"@/lib/auth-server\";\nimport { processScanFindings, captureScanReports } from \"@/lib/scan-utils\";\nimport type { Prisma } from \"@prisma/client\";\nimport fs from \"fs\";\n\ntype ActiveScan = {\n  id: string;\n  target: string;\n  status: \"running\" | \"completed\" | \"failed\" | \"translating\";\n  startTime: number;\n  logs: string[];\n  vulnerabilities?: number;\n  sourcePath?: string;\n  targetUrl?: string;\n  config?: string;\n  sessionId?: string;\n  duration?: string;\n  process?: ChildProcess | null;\n};\n\ndeclare global {\n  var activeScan: ActiveScan | null;\n}\n\nexport async function POST(req: Request) {\n  const { targetUrl, sourcePath, config, scanId: existingScanId } = (await req.json()) as {\n    targetUrl: string;\n    sourcePath: string;\n    config: string;\n    scanId?: string;\n  };\n\n  // Check for already running scan in memory or DB\n  const runningScanInDb = await prisma.scan.findFirst({\n    where: { status: \"running\" }\n  });\n\n  if (global.activeScan || (runningScanInDb && runningScanInDb.id !== existingScanId)) {\n    return NextResponse.json({ error: \"A scan is already in progress. Please wait for it to complete or stop it manually.\" }, { status: 400 });\n  }\n\n  // Auth Check\n  const { payload, errorResponse } = await withAuth(['ADMIN', 'SECURITY']);\n  if (errorResponse) return errorResponse;\n\n  const userId = payload?.id;\n\n  let existingLogs = \"\";\n  let existingStartTime = Date.now();\n  let existingVulnCount = 0;\n\n  if (existingScanId) {\n    const existing = await prisma.scan.findUnique({ where: { id: existingScanId } });\n    if (existing) {\n      existingLogs = existing.logs || \"\";\n      existingStartTime = existing.startTime.getTime();\n      existingVulnCount = existing.vulnerabilities;\n    }\n  }\n\n  const scanId = existingScanId || `SCAN-${new Date().getTime()}`;\n  const configPath = `configs/${config}`;\n\n  // Log preloading: Split into lines to maintain shifting logic\n  let preloadedLogs: string[] = [];\n  if (existingLogs) {\n    const lines = existingLogs.split(\"\\n\");\n    if (lines.length > 0 && lines[lines.length - 1] === \"\") lines.pop(); // Remove trailing empty line\n    preloadedLogs = lines.map(l => l + \"\\n\");\n    preloadedLogs.push(\"--- Scan Restarted ---\\n\");\n  }\n\n  const scanData: ActiveScan = {\n    id: scanId,\n    target: targetUrl,\n    status: \"running\" as const,\n    startTime: existingStartTime,\n    logs: preloadedLogs,\n    sourcePath: sourcePath,\n    targetUrl,\n    config,\n    vulnerabilities: existingVulnCount,\n  };\n\n  global.activeScan = scanData;\n\n  // Persist scan to DB (Upsert logic to avoid duplication on restarts)\n  if (existingScanId) {\n    console.log(`[Scan] Restarting existing scan: ${existingScanId}`);\n    await prisma.scan.update({\n      where: { id: existingScanId },\n      data: {\n        status: \"running\",\n        endTime: null,\n        duration: null,\n      }\n    });\n    // Removed: delete findings at start. They will be refreshed at the end.\n  } else {\n    // Check if there's a previous completed scan with same parameters\n    const previousScan = await prisma.scan.findFirst({\n      where: {\n        targetUrl,\n        sourcePath,\n        status: { in: [\"completed\", \"failed\"] }\n      },\n      orderBy: { startTime: \"desc\" }\n    });\n\n    if (previousScan) {\n      console.log(`[Scan] Creating NEW scan ${scanId} (previous scan ${previousScan.id} was ${previousScan.status})`);\n    } else {\n      console.log(`[Scan] Creating FIRST scan ${scanId} for ${targetUrl}`);\n    }\n\n    // New scan: create with vulnerabilities = 0 to avoid showing stale data\n    await prisma.scan.create({\n      data: {\n        id: scanId,\n        targetUrl,\n        sourcePath,\n        config,\n        status: \"running\",\n        vulnerabilities: 0, // Initialize to 0 for new scans\n        userId,\n      }\n    });\n  }\n\n  const engineDir = process.env.ENGINE_DIR || \"/home/ubuntu/dokodemodoor\";\n  const proc = spawn(\"npx\", [\n    \"zx\",\n    \"./dokodemodoor.mjs\",\n    targetUrl,\n    sourcePath,\n    \"--config\",\n    configPath\n  ], {\n    cwd: engineDir,\n    env: { ...process.env, FORCE_COLOR: \"3\" }\n  });\n\n  if (global.activeScan) {\n    global.activeScan.process = proc;\n  }\n\n  proc.stdout.on(\"data\", (data) => {\n    const lines = data.toString();\n    global.activeScan?.logs.push(lines);\n    const maxLogs = parseInt(process.env.MAX_LOG_LINES_IN_MEMORY || \"5000\");\n    if (global.activeScan && global.activeScan.logs.length > maxLogs) {\n      global.activeScan.logs.shift();\n    }\n  });\n\n  proc.stderr.on(\"data\", (data) => {\n    global.activeScan?.logs.push(data.toString());\n  });\n\n  // Track vulnerabilities in real-time\n  const findingsInterval = setInterval(() => {\n    if (global.activeScan && global.activeScan.id === scanId) {\n      processScanFindings(scanId, sourcePath).catch(console.error);\n    } else {\n      clearInterval(findingsInterval);\n    }\n  }, 5000);\n\n  // Capture session ID from engine store after a delay\n  // (Engine creates session immediately after spawn, but might take a few seconds to write to disk)\n  const captureSessionId = async (retryCount = 0) => {\n    try {\n      const STORE_PATH = process.env.STORE_PATH || \"/home/ubuntu/dokodemodoor/.dokodemodoor-store.json\";\n      if (!fs.existsSync(STORE_PATH)) {\n        if (retryCount < 5) setTimeout(() => captureSessionId(retryCount + 1), 3000);\n        return;\n      }\n\n      const store = JSON.parse(fs.readFileSync(STORE_PATH, \"utf-8\"));\n      const sessions = store.sessions || {};\n\n      let matchedSessionId = \"\";\n      let latestTimestamp = 0;\n\n      const scanStartTime = scanData.startTime; // This is the numerical timestamp\n\n      for (const [sessionId, sessionData] of Object.entries(sessions)) {\n        const session = sessionData as { webUrl?: string; repoPath?: string; createdAt?: string };\n        if (session.webUrl === targetUrl && session.repoPath === sourcePath) {\n          const sessionTime = session.createdAt ? new Date(session.createdAt).getTime() : 0;\n\n          // Only pick sessions created AROUND or AFTER the scan started\n          // Allowing 10 seconds buffer behind in case of clock drifts,\n          // but prioritizing the absolute latest.\n          if (sessionTime > latestTimestamp) {\n            latestTimestamp = sessionTime;\n            matchedSessionId = sessionId;\n          }\n        }\n      }\n\n      // Verification: If the matched session is older than the scan start time,\n      // it might be an old session and the new one isn't written yet.\n      // Scan start time is T. If latest matching session is T-1hour, wait for the new one.\n      const isNewSession = latestTimestamp > (scanStartTime - 30000); // Created within 30s of scan start or later\n\n      if (matchedSessionId && isNewSession) {\n        console.log(`[Scan] Captured CORRECT engine session ID: ${matchedSessionId} (Session Time: ${new Date(latestTimestamp).toISOString()}, Scan Start: ${new Date(scanStartTime).toISOString()})`);\n\n        await prisma.scan.update({\n          where: { id: scanId },\n          data: { sessionId: matchedSessionId }\n        });\n\n        if (global.activeScan && global.activeScan.id === scanId) {\n          global.activeScan.sessionId = matchedSessionId;\n        }\n      } else {\n        if (retryCount < 10) {\n          console.log(`[Scan] Session not found or too old. Retrying... (${retryCount + 1}/10)`);\n          setTimeout(() => captureSessionId(retryCount + 1), 3000);\n        } else {\n          console.warn(`[Scan] Failed to capture new session ID after 10 retries.`);\n        }\n      }\n    } catch (err) {\n      console.error(`[Scan] Error capturing session ID:`, err);\n    }\n  };\n\n  setTimeout(() => captureSessionId(0), 5000); // Start checking after 5s\n\n\n  proc.on(\"close\", async (code) => {\n    const status = code === 0 ? \"completed\" : \"failed\";\n    const endTime = Date.now();\n    const duration = `${Math.round((endTime - scanData.startTime) / 1000)}s`;\n\n    // Process and save findings before updating scan status\n    const vulnCount = await processScanFindings(scanId, sourcePath);\n\n    // Capture all deliverables into DB for permanent storage\n    await captureScanReports(scanId, sourcePath);\n\n    await prisma.scan.update({\n      where: { id: scanId },\n      data: {\n        status,\n        endTime: new Date(endTime),\n        duration,\n        vulnerabilities: vulnCount,\n        logs: scanData.logs.join(\"\"), // Persist logs to DB on finish\n      }\n    });\n\n    global.activeScan = null;\n  });\n\n  return NextResponse.json({ scanId });\n}\n\nexport async function GET(req: Request) {\n  const { searchParams } = new URL(req.url);\n  const page = parseInt(searchParams.get(\"page\") || \"1\");\n  const limit = parseInt(searchParams.get(\"limit\") || \"10\");\n  const query = searchParams.get(\"query\") || \"\";\n  const status = searchParams.get(\"status\") || \"all\";\n\n  const skip = (page - 1) * limit;\n\n  const where: Prisma.ScanWhereInput = {};\n  if (query) {\n    const matchingProjects = await prisma.project.findMany({\n      where: { name: { contains: query } },\n      select: { localPath: true }\n    });\n    const projectPaths = matchingProjects.map(p => p.localPath);\n\n    where.OR = [\n      { targetUrl: { contains: query } },\n      { id: { contains: query } },\n      { sourcePath: { in: projectPaths } }\n    ];\n  }\n  if (status !== \"all\") {\n    where.status = status;\n  }\n\n  const [history, total, projects, stats] = await Promise.all([\n    prisma.scan.findMany({\n      where,\n      orderBy: { startTime: \"desc\" },\n      skip,\n      take: limit,\n      select: {\n        id: true,\n        targetUrl: true,\n        status: true,\n        startTime: true,\n        endTime: true,\n        duration: true,\n        vulnerabilities: true,\n        sourcePath: true,\n        config: true,\n      }\n    }),\n    prisma.scan.count({ where }),\n    prisma.project.findMany({\n      select: { localPath: true, name: true }\n    }),\n    prisma.scan.groupBy({\n      by: ['status'],\n      _count: {\n        id: true\n      }\n    })\n  ]);\n\n  const projectMap = new Map(projects.map(p => [p.localPath, p.name]));\n  const historyWithProjectName = history.map(scan => ({\n    ...scan,\n    projectName: scan.sourcePath ? projectMap.get(scan.sourcePath) : null\n  }));\n\n  const counts = {\n    total: stats.reduce((acc, curr) => acc + curr._count.id, 0),\n    running: stats.find(s => s.status === 'running')?._count.id || 0,\n    translating: stats.find(s => s.status === 'translating')?._count.id || 0,\n    completed: stats.find(s => s.status === 'completed')?._count.id || 0,\n    failed: stats.find(s => s.status === 'failed')?._count.id || 0,\n  };\n\n  return NextResponse.json({\n    active: global.activeScan ? {\n      ...global.activeScan,\n      vulnerabilities: global.activeScan.vulnerabilities || 0,\n      logs: undefined,\n      projectName: global.activeScan.sourcePath ? projectMap.get(global.activeScan.sourcePath) : null\n    } : null,\n    history: historyWithProjectName,\n    stats: counts,\n    pagination: {\n      total,\n      page,\n      limit,\n      totalPages: Math.ceil(total / limit)\n    }\n  });\n}","exitCode":0}
```