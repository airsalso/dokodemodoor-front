# Staged: src/app/api/auth/login/route.ts

```
{"status":"success","output":"import { NextResponse } from \"next/server\";\nimport { prisma } from \"@/lib/prisma\";\nimport bcrypt from \"bcryptjs\";\nimport { SignJWT } from \"jose\";\nimport { cookies } from \"next/headers\";\nimport crypto from \"crypto\";\n\nconst SECRET = new TextEncoder().encode(process.env.JWT_SECRET || \"default_secret_key_12345\");\n\nexport async function POST(req: Request) {\n  try {\n    const { username, password, rememberMe } = (await req.json()) as {\n      username: string;\n      password: string;\n      rememberMe?: boolean;\n    };\n\n    console.debug(`[Login] Attempt: ${username}, Remember Me: ${rememberMe}`);\n    const user = await prisma.user.findUnique({\n      where: { username },\n    });\n\n    if (!user) {\n      console.debug(`[Login] User not found: ${username}`);\n      return NextResponse.json({ error: \"Invalid username or password\" }, { status: 401 });\n    }\n\n    const isMatch = await bcrypt.compare(password, user.password);\n    console.debug(`[Login] Password match for ${username}: ${isMatch}`);\n\n    if (!isMatch) {\n      return NextResponse.json({ error: \"Invalid username or password\" }, { status: 401 });\n    }\n\n    // Check account status\n    const userStatus = user.status;\n    console.debug(`[Login] User status for ${username}: ${userStatus}`);\n\n    if (userStatus === \"INACTIVE\") {\n      return NextResponse.json({ error: \"Your account is suspended. Please contact admin.\" }, { status: 403 });\n    }\n    if (userStatus === \"DELETED\") {\n      return NextResponse.json({ error: \"This account has been deleted.\" }, { status: 403 });\n    }\n\n    // Create access token (short-lived)\n    const accessTokenExpiry = process.env.JWT_ACCESS_TOKEN_EXPIRY || \"4h\";\n    const accessToken = await new SignJWT({ id: user.id, username: user.username, role: user.role || \"USER\" })\n      .setProtectedHeader({ alg: \"HS256\" })\n      .setIssuedAt()\n      .setExpirationTime(accessTokenExpiry)\n      .sign(SECRET);\n\n    const cookieStore = await cookies();\n    const isProduction = process.env.NODE_ENV === \"production\";\n\n    // For sameSite: \"none\", secure must be true (browser requirement)\n    // In development, we use \"lax\" to avoid the secure requirement\n    const sameSitePolicy = isProduction ? \"lax\" : \"lax\";\n    const isSecure = isProduction && process.env.COOKIE_SECURE === \"true\";\n\n    // Set new access token cookie\n    cookieStore.set(\"auth_token\", accessToken, {\n      httpOnly: true,\n      secure: isSecure,\n      sameSite: sameSitePolicy,\n      maxAge: 60 * 60 * 4, // 4 hours\n      path: \"/\",\n    });\n\n    // If \"Remember Me\" is checked, create a refresh token (long-lived: 7 days)\n    if (Boolean(rememberMe)) {\n      // Clean up old refresh tokens for this user\n      await prisma.refreshToken.deleteMany({\n        where: {\n          userId: user.id,\n          expiresAt: { lt: new Date() }\n        }\n      });\n\n      // Generate secure refresh token\n      const refreshToken = crypto.randomBytes(64).toString('hex');\n      const expiryDays = parseInt(process.env.JWT_REFRESH_TOKEN_EXPIRY_DAYS || \"7\");\n      const expiresAt = new Date();\n      expiresAt.setDate(expiresAt.getDate() + expiryDays); // 7 days\n\n      // Store refresh token in database\n      await prisma.refreshToken.create({\n        data: {\n          userId: user.id,\n          token: refreshToken,\n          expiresAt,\n          lastActivity: new Date()\n        }\n      });\n\n      // Set refresh token cookie\n      cookieStore.set(\"refresh_token\", refreshToken, {\n        httpOnly: true,\n        secure: isSecure,\n        sameSite: sameSitePolicy,\n        maxAge: 60 * 60 * 24 * expiryDays,\n        path: \"/\",\n      });\n\n      console.debug(`[Login] Refresh token created for ${username}`);\n    }\n\n    return NextResponse.json({\n      success: true,\n      user: {\n        id: user.id,\n        username: user.username,\n        role: user.role || \"USER\"\n      }\n    });\n  } catch (error) {\n    console.error(\"Login Error:\", error);\n    return NextResponse.json({ error: \"Internal Server Error\" }, { status: 500 });\n  }\n}","exitCode":0}
```